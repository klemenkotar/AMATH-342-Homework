# Homework 1
## Klemen Kotar / AMATH 342 with Eric Shea Brown

### Part A - MATLAB Tutorial Problems

#### Exercise 4.1

INTEGRATOR STAGE 2: Write a code **integrator_2.m** which:

- defines a signal **signal_vector** (a vector of signal values at different timepoints) 
- defines a threshold **thresh**

and computes as its answer the first time that the cumulative sum of the signal crosses the threshold.

```
clear all;

t=[1:10];
signal_vector = sin(t);
thresh = 0.5;

for n = t;
    if (signal_vector(n) > thresh);
        disp("We are crossing the threshold at time t = : " + signal_vector(n))
        break
    end;
end;
```

#### Exercise 3.2

Imagine that you have a giant neural network, and each cell is either firing (“on”) or not (“off”). Each second, for every neuron that is already on, two more switch on. This is a model of EXCITATORY SYNAPTIC COMMUNICATION from the “on” neurons. At time *t = 0* seconds, 1 neuron is “on.” Write a program, called **neural_explosion.m** that does the following:

-using a for loop, compute a vector number_on that is the number of neurons on at each second, from t = 0 to t = 30 seconds.
-Make a plot of the number of neurons on vs. time. Label the axes *“time”* and *“number on.”* Hint: type ```help plot```!

```
clear all;

number_on = [1];
for n = [1:30]
    number_on(n+1) = number_on(n) * 3;
end
disp(number_on)
t = [0:30];

plot(t, number_on, "-*")
title("number of neurons on vs. time");
xlabel("time");
ylabel("neurons on");
```
Executing the above program produces the following graph:


![alt text](number_of_neurons_on_vs_time.png)


#### Exercise 5.1

Write a function m-file **rmatrix.m** which takes as arguments 3 matrices A, S, Z, and returns the matrix B = A + S. ∗ Z.

```
function f=rmatrix(A, S, Z)
    U = S .* Z;
    f = A + U;
return;
```


### Part B - Spike Train Analysis and Tuning Curves

When I read though this exercise I decided to approach it partially **backwards**. 

The program **generate_noisy_data_cockroach.m** is producing simulations of measurments of spike trains. It produces a specified amount of trials to give us better accuracy.
Our first task is to analyzie just a single output of the program as a raster plot. The trouble with this task is that we have to specify an angle at which we want to stimulate the cells to produce the spiketrain. Since we have no prior knowledge of wich angles are preffered by the cells, we have to blindly guess the angle for our initial analysis. Although this is closer to the prodedure we would ungergo if we were measuring novel data (i.e. data not generated by a rng), it can also lead to a very boring analysis.
To circumnavigate this I started by plotting the tuning curves for cells 1, 2 and 3 in order to identiy their prefered positions, so I could analyze the individual spike trains at "interesting" positions.

In order to achieve my goal I first decided to re-implement the program **generate_noisy_data_cockroach.m** as a function, of three arguments (stimDir, cell_num, ntrials).

```
% This is the generate_noisy_data_cockroach.m file modified to behave as a
% function instead of a human input script

% This code will generate a spiking response to an input based on a tuning
% curve and assuming (inhomogeneous) Poisson firing. The response adapts
% over time, with a time constant of tau

function spiketrain = noisy_data(stimDir, cell_num, ntrials)

    rand('state',sum(100*clock));

    nmsec = 300;    % number of milliseconds to record for
    times= 1:nmsec; % vector of time points (1 msec apart)

    spiketrain = zeros(ntrials,nmsec);      % set up output data

    rate = cockroach_tuning(stimDir, cell_num); %returns rate, in Hz.       
    tau = 100;      % adaptation time constant in msec
    delta_t=0.001; %time bin, in seconds (1 msec)
    ratefun = rate*exp(-times/tau);  % adapting rate function 



    for j = 1:ntrials

        for i = 1:nmsec

                spiketrain(j,i) = round(rand + ratefun(i)*delta_t -1/2 );

        end

    end
    
return
```

This allows me to call the noisy_data() methode in a loop, instead of manually creating matrices for each data point.

Next I needed a way to obtain the firing rate from the spiketrain vector. I created a simple helper methode that takes the mean of each row of the matrix returned by noisy_data, in effect returning a matrix of 1 column containing the firing_rate for each trial.

```
function f = trial_mean(x)
    f = mean(x);
return;
```

Finally I wanted to compute the average trial spikes at every angle, so I wrote anothe helper methode that takes a matrix returned by noisy_data 

